---
# 这是文章的标题
title: 第三章-面向对象编程
# 这是页面的图标
icon: pepper-hot
# 这是侧边栏的顺序
order: 3
# 设置作者
author: god23bin
# 设置写作时间
date: 2024-01-17 13:14:13
# 一个页面可以有多个分类
category:
  - Java基础
# 一个页面可以有多个标签
tag:
  - Java
---

## 第三章-面向对象编程

### 一、OOP 的概念

**OOP（Object Oriented Programming）**，即面向对象编程，它可以说是一种规范（paradigm）、一种范式、一种思想，都可以。

主要的一种思想，就是抽象，将程序抽象出现实世界中的对象，在程序中操作对象，就如同在现实世界操作对象一样。

OOP 包括的内容如下：

- **对现实生活的建模**：这种范式（paradigm）描述的是现实生活中的系统，其中的交互是真实物体之间的交互。
- **交互**：它将应用程序建模为一组相互影响的相关对象。
- **现实世界对象**：编程实体（programming entity）被建模为一个**类（class）**，表示相关现实世界对象的集合。
- **对象的优先级**：编程从现实世界的 **对象和类（objects and classes）** 的概念开始。
- **组织（Organization）**：应用程序分为多个包。
- **包（Package）**：包是类的集合。
- **类（Class）**：类是**一组相似的现实世界对象的封装（an encapsulated group of similar real−world objects）**。

相关概念：

**1. 对象（Object ）**

现实世界的对象有两个特征：它们都有**状态和行为（state and behavior）**。让我们看下面的图例来理解对象。

例子：

```java
// 定义的一个名为 Dog 的类，用于描述现实世界中的狗
public class Dog {
   // 定义一个字符串变量 name，用于描述狗的名字，依次类推，这些就是狗的状态
   String name;
   // 狗的品种
   String breed;
   // 狗的颜色
   String color;
   // 狗是否饥饿
   boolean hungry;
   
   // 定义一个方法 barking，用于描述狗是怎样叫的，以此类推，这些就是狗的行为
   void barking() {
   }

   void fetching() {
   }

   void wagging() {
   }
   
   void tail() {
   }
}
```

对象将其信息存储在属性中，并通过方法公开其行为。

**2. 数据封装（Data Encapsulation）**

通过对象的方法向用户隐藏类的实现细节被称为数据封装。在面向对象编程中，它将代码和数据绑定在一起，使其免受外界干扰。

**3. 公共接口（Public Interface）**

在单台计算机或网络中，软件与实体之间的交互点被称为公共接口。这有助于数据安全。在交互过程中，其他对象只能使用那些公共接口（即对外公开的方法）来改变对象的状态。

**4. 类（Class）**

类是一组具有共同方法的对象。它可以被视为创建对象的蓝图。

类是被动的，彼此之间并不通信，想要通信，就需要将类实例化，使用实例化对象进行交互通信。

**5. 继承（Inheritance）**

一般来说，继承是获取属性的过程。在 OOP 中，指一个对象继承另一个对象的属性。

**6. 多态（Polymorphism）**

多态是指多个类使用相同的方法名，并被派生类重新定义方法的过程。



我们一般提到面向对象，就会提到**封装、继承、多态**，这也是常说的面向对象三大特性。

### 二、对象和类

Java 是一门面向对象的语言，有着面向对象的特性，所以有着如下的概念：

- 封装（Encapsulation）
- 继承（Inheritance）
- 多态（Polymorphism）
- 抽象（Abstraction）
- 类（Classes）
- 对象（Objects）
- 实例（Instance）
- 方法（Method）
- 消息传递（Message Passing）

**理解对象和类（Object and Classes）**

**对象**：对象具有状态和行为。

举例：一只狗是一个对象，狗有状态，比如颜色、名字、品种。狗也有行为，比如摇尾巴、吠叫、吃东西。

对象是类的实例，一个类可以有很多实例。

**类**：类可以定义为一个**模板/蓝图（template/blueprint）**，描述其类型的对象所支持的**行为/状态（behavior/state）**。

#### Java 中的对象

现在，让我们深入探讨一下什么是对象？

如果我们考虑一下现实世界，我们可以发现身边有很多物体，汽车、狗、人等等。所有这些物体都有状态和行为。而这些物体就是现实世界中的对象。

如果我们考虑一只狗，那么它的**状态**是名字、品种、颜色，而它的**行为**是吠叫、摇尾巴、奔跑。

那么我们将**软件对象**与**现实世界中的对象**进行比较，它们的特征是非常相似。

软件对象也有**状态和行为**。软件对象的状态是存储在**属性/字段**中的，而行为则是通过**方法**表现出来的。

因此，在软件开发中，方法对对象的内部状态进行操作，对象与对象之间的通信也是通过方法完成的。

#### Java 中的类

类是一个蓝图，我们可以根据此蓝图创建单个对象，创建的对象也称为该类的一个**实例（Instance）**。

例子：一个 *Dog* 类，可以根据 *Dog* 类创建 Dog 对象。

```java
public class Dog {
   String breed;
   int age;
   String color;

   void barking() {
   }

   void hungry() {
   }

   void sleeping() {
   }
}
```

类可以包含以下任意的变量类型

- **局部变量**：在方法、构造方法或代码块内定义的变量称为局部变量。变量将在方法内声明和初始化，方法完成后变量将被销毁。
- **实例变量**：实例变量是类内但在任何方法之外的变量。这些变量在类实例化时被初始化。可以从该特定类的任何方法、构造方法或块内部访问实例变量。
- **类变量/静态变量**：类变量是在类内、任何方法之外使用 static 关键字声明的变量。

类可以有任意数量的变量和方法，上面的例子中，breed、age、color 是变量，而 barking()、hungry()、sleeping() 是方法。

#### 构造方法

在讨论类时，最重要的子话题之一就是**构造方法（Constructors，也称构造函数、构造器）**。

每个类都有一个构造方法。如果我们没有为一个类明确编写一个构造方法，那么 Java 编译器就会为该类创建一个默认的构造方法。

每次创建新对象时，至少会调用一个构造方法。构造方法的主要规则是它们应与类的名称相同。与此同时，一个类可以有多个构造方法。

示例：

```java
public class Puppy {
   // 无参的构造方法
   public Puppy() {
   }
   
   // 有参的构造方法，参数是 name
   public Puppy(String name) {
      // 方法体
   }
}
```

需要注意的是，构造方法没有显式的返回类型。

#### 创建对象

前面我们提到过，类为对象提供了蓝图。所以，对象是根据类创建出来的。在 Java 中，**new** 关键字用于创建新对象。

从类创建对象有三个步骤：

1. **声明（Declaration）**：具有变量名和对象类型的变量声明。
2. **实例化（Instantiation）**：**new** 关键字用于创建对象。
3. **初始化（Initialization）**：**new** 关键字后面是对构造方法的调用。此调用是用于初始化新对象的。

示例：

```java
public class Puppy {
   public Puppy(String name) {
      // 有参构造方法，参数 name
      System.out.println("传递的 name 是:" + name );
   }

   public static void main(String []args) {
      // 使用 new 关键字创建一个 Puppy 对象，myPuppy
      Puppy myPuppy = new Puppy("tommy");
   }
}
```

我们单独拎出这一语句：

```java
Puppy myPuppy = new Puppy("tommy");
```

首先，**声明**，即 `Puppy myPuppy`，这里声明了名为 myPuppy 的变量，该变量的数据类型是 Puppy，是一种引用类型（对象类型）。

接着，使用 new 关键字进行**实例化**，后面跟着对构造方法的调用 `Puppy("tommy")`，传递了一个字符串参数，调用完成对象的**初始化**。

我们可以编译并运行上面给出的程序，就可以看到这样的输出：

```console
传递的 name 是:tommy
```

#### 访问实例变量和方法

实例变量和方法是通过创建的对象访问的。要访问实例变量，可以通过如下的写法来访问：

```java
// 创建对象
对象类型 对象名称 = new 对象类型();
// 访问该对象的变量
对象名称.对象变量名;
// 访问该对象的方法
对象名称.对象方法名();
```

示例：下面演示创建一个小狗对象 myPuppy，并访问 myPuppy 的年龄变量 puppyAge

```java
public class Puppy {
   // 定义变量（属性、字段）
   int puppyAge;

   public Puppy(String name) {
      // 有参构造方法，参数 name
      System.out.println("小狗的名字是:" + name );
   }

   public void setAge(int age) {
      puppyAge = age;
   }

   public int getAge( ) {
      System.out.println("小狗的年龄是:" + puppyAge );
      return puppyAge;
   }

   public static void main(String []args) {
      // 创建小狗对象
      Puppy myPuppy = new Puppy( "tommy" );

      // 调用小狗类的方法去设置小狗的年龄
      myPuppy.setAge(2);

      // 调用小狗类的另一个方法来获取小狗的年龄
      myPuppy.getAge();

      // 也可以通过 对象.属性 的形式来访问实例变量，获取小狗年龄
      System.out.println("变量值:" + myPuppy.puppyAge );
   }
}
```

编译并运行上面程序，得到：

```console
小狗的名字是:tommy
小狗的年龄是:2
变量值:2
```

### 三、Java 中的包（package）

实际上，就是一个目录（文件夹），主要作用就是把 Java 文件分类，便于管理，因为使用 Java 开发应用程序时，将编写数百个类和接口，因此对这些类进行分类是必须的，并且可以使工作变得更加轻松。

#### import 声明

在 Java 中，如果给出一个**完全限定的名称**，其中包括**包和类名**，那么编译器可以轻松地找到源代码或类。

import 语句是一种能为编译器提供查找特定类的正确位置的语句，换句话说，能将特定类的代码导入到当前类中。

例如，以下行将要求编译器加载目录 java_installation/java/io 中可用的所有类：

```java
import java.io.*;
```

示例：我们创建两个类，它们是 *Employee* 和 *EmployeeTest*。

首先是 *Employee* 类，我们将下面的 *Employee* 类的代码保存在 Employee.java 文件中。

```java
import java.io.*;

public class Employee {

   String name;
   int age;
   String designation;
   double salary;

   // 构造方法
   public Employee(String name) {
      this.name = name;
   }

   // 设置员工年龄到 age 变量
   public void empAge(int empAge) {
      age = empAge;
   }

   // 设置员工职务名称到 designation 变量
   public void empDesignation(String empDesig) {
      designation = empDesig;
   }

   // 设置员工薪水到 salary 变量
   public void empSalary(double empSalary) {
      salary = empSalary;
   }

   /* 打印员工信息细节 */
   public void printEmployee() {
      System.out.println("员工名称:" + name);
      System.out.println("员工年龄:" + age);
      System.out.println("员工职务:" + designation);
      System.out.println("员工薪水:" + salary);
   }
}
```

程序执行是从 main 方法开始。所以，我们想要运行这个 Employee 类，就应该有一个 main 方法并创建 Employee 对象，再调用打印的方法。

下面是 *EmployeeTest* 类，它创建 *Employee* 类的两个实例对象，并调用每个对象的方法来为每个变量赋值。

将以下代码保存在 EmployeeTest.java 文件中

```java
import java.io.*;

public class EmployeeTest {

   public static void main(String args[]) {
      /* 使用构造方法创建两个实例对象 */
      Employee empOne = new Employee("James Smith");
      Employee empTwo = new Employee("Mary Anne");

      // 分别为这两个对象调用方法
      empOne.empAge(26);
      empOne.empDesignation("Senior Software Engineer");
      empOne.empSalary(1000);
      empOne.printEmployee();
       
      System.out.println();

      empTwo.empAge(21);
      empTwo.empDesignation("Software Engineer");
      empTwo.empSalary(500);
      empTwo.printEmployee();
   }
}
```

编译这两个类：

```cmd
javac Employee.java
javac EmployeeTest.java
```

运行 EmployeeTest 类：

```cmd
java EmployeeTest
```

得到打印输出的内容：

```console
员工名称:James Smith
员工年龄:26
员工职务:Senior Software Engineer
员工薪水:1000

员工名称:Mary Anne
员工年龄:21
员工职务:Software Engineer
员工薪水:1000
```

### 四、一个 Java 源文件声明的规则

在源文件中声明类、import 语句和 package 语句时，这些规则至关重要。

- 每个源文件只能有一个 **public** 类。
- 一个源文件可以有多个非 **public** 类。
- 这个 public 类的类名也应该是源文件的名称，并在末尾添加**.java 。**例如：类名称是 *public class Employee{}* 那么源文件应该是 Employee.java。
- 如果这个类是在包（**package**）中定义的，则 package 语句应该是源文件中的第一条语句。
- 如果存在 **import** 语句，则必须将它们写在包语句和类声明之间。如果没有 **package** 语句，则 import 语句应该是源文件中的第一行。
- import 语句和 package 语句将暗示源文件中存在的所有类。

类有多种访问级别（private、protected、public），并且有不同类型的类，比如抽象类、final 类等。我们将在访问修饰符一章中解释所有这些。

除了上述类型的类之外，Java 还有一些特殊的类，称为内部类和匿名类。

### 五、类属性

Java 中的类是用户定义的数据类型、蓝图、分类，描述其类型的对象支持的行为/状态。

示例：*Dog* 类

```java
public class Dog {
   String breed;
   int age;
   String color;

   void barking() {
   }

   void hungry() {
   }

   void sleeping() {
   }
}
```

在上面的类中，我们有品种、年龄和颜色等**字段**，也称为**类属性**。

> 也有称为**成员变量**，在我看来，当一个类创建出一个实例时，对于这个实例拥有的属性，我们可以称这个属性是该成员（该实例）的变量。也许就是有太多种翻译，太多种名词来描述同一件东西了，太过于咬文嚼字了，这也是我认为学习 Java 初期的困难之一。

类属性定义程序执行期间类的状态。默认情况下，可以使用以下语法在类方法中访问类属性。

```java
public class Dog {
   // 私有的类属性
   private String name;
   
   public void setName(String name){
      // 使用 this.name 的方式访问类属性
      this.name = name;
   }
  
   public String getName(){
      return name;   
   }   
}
```

在类方法中，我们使用 this.name 访问类属性 name。这种方式有助于通过外部对象访问和修改类属性。

**作为最佳实践，类属性应该是私有的，类方法应该是公开的、公共的，并且类属性应该仅通过类方法访问/修改。**

例子：

```java
package cn.god23bin.summary;

class Dog {
   // 私有的类属性
   private String name;

   // 公开的、公共的类方法，可以通过该方法修改类属性 name
   public void setName(String name){
      this.name = name;
   }

   // 公开的、公共的类方法，可以通过该方法访问类属性 name
   public String getName(){
      return name;   
   }   
}

public class Tester {
   public static void main(String[] args) {
      Dog dog = new Dog();
      // 通过调用 setName() 修改类属性
      dog.setName("Tommy");
      // 通过调用 getName() 访问类属性
      System.out.println(dog.getName());
   }
}
```

编译后运行，得到：

```console
Tommy
```

如果我们将类属性设置为公开的，那么类外部是可以直接访问类属性的，如下：

```java
public class Dog {
   // 将原本的 private 修改为 public
   public String name;
}
```

现在可以直接访问/修改该属性，而无需调用对象的任何方法。但这不是一个好的做法。

直接访问/修改，就是通过 **对象名.属性名** 的形式，如下：

```java
public class Tester {
   public static void main(String[] args) {
      Dog dog = new Dog();
      // 对象名.属性名
      dog.name = "Tommy";
      System.out.println(dog.name);
   }
}
```

可以给类属性加上 **final** 关键字，将类属性设置为只读不可修改。

```java
public class Dog {
   // 使用 final 关键字修饰
   public final String name;
}
```

现在这个属性是不能修改的，一经设置，就不能改变，如果我们尝试修改这个属性，JVM 就会报错。

```java
package cn.god23bin.summary;

class Dog {
   // 没写 public，默认就是 public，这里赋值后，便不能改变，final 一般用作常量
   final String name = "Tommy";  
}

public class Tester {
   public static void main(String[] args) {
      Dog dog = new Dog();
      dog.name = "Tommy";  // 这里就会发生错误，不能赋值改变，因为有 final 关键字修饰
      System.out.println(dog.name);
   }
}
```

编译并运行 Tester，得到：

```console
Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
	The final field Dog.name cannot be assigned

	at cn.god23bin.summary.Tester.main(Tester.java:10)
```

### 六、类方法

类中的方法是这样定义的，写法如下：

```java
public class class-name {
   public int methodName(int a, int b) {
      // body 方法体
   }
}
```

方法由这几个部分构成：

- **public**：这个是修饰符，表示该方法是公开的，公共的
- **int**：这个是返回类型，表示该方法将返回 int 类型的数据
- **methodName**：这个是方法的名称，遵循驼峰命名
- **a, b**：这两个是形式参数
- **int a, int b**：这整个部分是参数列表

#### 方法的定义

具体来说，是这样的：

```java
// 修饰符 返回类型 方法名(参数列表) { 方法体 }
modifier returnType nameOfMethod (Parameter List) {
   // method body
}
```

- **modifier**：它定义方法的访问类型，比如 private、protected、public。
- **returnType**：方法可能返回一个值，如果不返回，那么就是 void，返回为空。
- **nameOfMethod**：这是方法名称。而**方法签名（method signature）**则是由**方法名称和参数列表**组成。
- **Parameter List**：参数列表，它指定了方法的参数类型、顺序和数量。这些是可选的，方法可以包含零个参数。
- **method body**：方法体定义了方法对语句执行的操作。

例子：

```java
/** 返回 n1 和 n2 中的最小值 */
public int minFunction(int n1, int n2) {
   int min;
   if (n1 > n2)
      min = n2;
   else
      min = n1;
   // 返回最小值
   return min; 
}
```

#### 方法的调用

为了使用我们编写的方法，那么我们就需要调用（Call）它。

方法调用后，要么有返回值，要么没有返回值。

没有返回值的方法调用就如同执行了一条语句一样，比如打印操作：

```java
System.out.println("Hello World!");
```

方法调用的过程是很简单的。当程序调用方法时，程序控制权将转移到被调用的方法。然后，这个被调用的方法会在以下**两种**情况下将控制权返回给调用者：

1. 执行到 return 语句
2. 执行到方法结束的右大括号处

示例：下面的程序演示了如何在类中定义方法以及如何调用该方法。

在 main() 方法中，我们创建了一个 *Util* 类对象，并调用它的 minFunction() 方法来获取给定两个数的最小值

```java
package cn.god23bin.summary;

class Util {
   public int minFunction(int n1, int n2) {
      int min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;
	  // 返回最小值
      return min; 
   }
}

public class Tester {
   
   public static void main(String[] args) {
      int a = 11;
      int b = 6;

      Util util = new Util();
	  // 调用 minFunction 方法，使用一个整型变量 c 接收方法的返回值
      int c = util.minFunction(a, b);
      System.out.println("最小值 = " + c);
   }
}
```

输出：

```console
最小值 = 6
```

#### void 关键字

**void** 关键字允许我们创建没有返回值的方法。

示例：

```java
public class ExampleVoid {

   public static void main(String[] args) {
      // 由于方法是静态的，所以直接调用；由于方法是无返回值的，所以不需要变量来接收返回值，就单独一条 Java 语句，以分号结束
      methodRankPoints(255.7);
   }

   // 该方法是静态的、无返回值的
   public static void methodRankPoints(double points) {
      if (points >= 202.5) {
         System.out.println("Rank:A1");
      }else if (points >= 122.4) {
         System.out.println("Rank:A2");
      }else {
         System.out.println("Rank:A3");
      }
   }
}
```

输出：

```console
Rank:A1
```

#### this 关键字

**this** 是 Java 中的一个关键字，表示当前类对象的引用，一般是在实例方法或构造方法中会使用到 this 关键字。

使用 this 关键字，可以便于我们去引用类的成员，例如构造方法、变量和方法。

**注意：关键字 this 仅能在实例方法或构造方法中使用**

一般来说，this 关键字用于：

1. **区分同名的实例变量和局部变量**。在构造方法或方法中，如果实例变量和局部变量的名称相同，应使用 **this** 将它们区分开来。

```java
class Student {
   // 实例变量 age
   int age;
   // 构造方法的形式参数，是一个和实例变量同名的局部变量 age
   Student(int age) {
      // 使用 this 就能够区分这个 age 是实例的变量还是局部变量
      this.age = age;
   }
}
```

2. **显示构造方法调用（explicit constructor invocation）**。

```java
class Student {
   int age
   Student() {
      // 这里的 this(20) 就是调用下方的有参构造方法，这就是显示构造方法调用
      this(20);
   }
   
   Student(int age) {
      this.age = age;	
   }
}
```

**示例：关于 this 关键字的示例程序**

```java
package cn.god23bin.summary;

public class Tester {
   // 实例变量 num
   int num = 10;
	
   Tester() {
      System.out.println("关于 this 关键字的示例程序");	
   }

   Tester(int num) {
      // 调用无参的构造方法
      this();
      
      // 将局部变量 num 赋值给实例变量 num
      this.num = num;	   
   }
   
   public void greet() {
      System.out.println("欢迎阅读这份 2024 的 Java 知识点总结，感谢支持！");
   }
      
   public void print() {
      // 局部变量 num
      int num = 20;
      
      // 打印局部变量
      System.out.println("局部变量 num 的值是: " + num);
      
      // 打印实例变量
      System.out.println("实例变量 num 的值是: " + this.num);
      
      // 调用类的方法 greet()
      this.greet();
   }
   
   public static void main(String[] args) {
      // 实例化当前测试类
      Tester obj1 = new Tester();
      
      // 调用 print() 方法
      obj1.print();
	  
      // 通过有参构造方法传递一个参数来构造测试对象
      Tester obj2 = new Tester(30);
      
      // 再次调用 print() 方法
      obj2.print(); 
   }
}
```

输出：

```console
关于 this 关键字的示例程序
局部变量 num 的值是: 20
实例变量 num 的值是: 10
欢迎阅读这份 2024 的 Java 知识点总结，感谢支持！
关于 this 关键字的示例程序
局部变量 num 的值是: 20
实例变量 num 的值是: 30
欢迎阅读这份 2024 的 Java 知识点总结，感谢支持！
```

#### 按值传递参数

**按值传递参数（Passing Parameters by Value）**

在调用有参方法的过程中，我们需要传递**参数**给方法的，那么参数是可以通过**值（Value）**来传递的或者通过**引用（Reference）**进行传递。

> Parameters can be passed by value or by reference

示例：按值传递参数

```java
public class swappingExample {

   public static void main(String[] args) {
      int a = 30;
      int b = 45;
      System.out.println("交换值之前, a = " + a + " 并且 b = " + b);

      // 调用交换方法
      swapFunction(a, b);
      System.out.println("\n**现在，交换前和交换后的值在这里是一样的**:");
      System.out.println("交换值之后, a = " + a + " 并且 b = " + b);
   }

   public static void swapFunction(int a, int b) {
      System.out.println("交换之前(Inside), a = " + a + " b = " + b);
      
      // Swap n1 with n2
      int c = a;
      a = b;
      b = c;
      System.out.println("交换之后(Inside), a = " + a + " b = " + b);
   }
}
```

输出：

```console
交换值之前, a = 30 并且 b = 45
交换之前(Inside), a = 30 b = 45
交换之后(Inside), a = 45 b = 30

**现在，交换前和交换后的值在这里是一样的**:
交换值之后, a = 30 and b is 45
```

可以看到，交换之后，main 方法中的 a 和 b 的值并没有发生交换，值仍然是原先的值，证明这里的传递是只传递了**值（value）**。

#### 方法重载

当一个类有两个或多个同名但参数不同的方法时，称为**方法重载（Method Overloading）**。它与**重写（Override）**不同。在重写中，方法具有相同的方法名称、类型、参数数量等。

让我们想一下前面写过的用于获取两个整数中最小值的程序。

如果，假设我们要找到 double 类型的最小数量。然后会引入重载的概念，创建两个或多个同名但参数不同的方法。

```java
public class ExampleOverloading {

   public static void main(String[] args) {
      int a = 11;
      int b = 6;
      double c = 7.3;
      double d = 9.4;
      int result1 = minFunction(a, b);
      
      // 相同的方法名，有着不同的参数列表
      double result2 = minFunction(c, d);
      System.out.println("最小值 = " + result1);
      System.out.println("最小值 = " + result2);
   }

   // 适用于整型的，找到两个数中最小值的方法
   public static int minFunction(int n1, int n2) {
      int min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;

      return min; 
   }
   
   // 适用于双精度浮点型的，找到两个数中最小值的方法
   public static double minFunction(double n1, double n2) {
     double min;
      if (n1 > n2)
         min = n2;
      else
         min = n1;

      return min; 
   }
}
```

输出：

```console
最小值 = 6
最小值 = 7.3
```

重载方法使程序具有可读性。在这里，两个方法虽然名称相同，但它们的参数不同。返回结果分别是整型和双精度浮点型中最小的数字。

#### 使用命令行参数

**命令行参数（Command-Line Arguments）**

有时，我们需要在运行程序时将一些信息传递到程序中，这时候就可以将命令行参数传递给 main() 方法来完成。

命令行参数是执行程序时在命令行上直接跟在程序名称后面的信息。

在 Java 程序中访问命令行参数非常容易。它们作为字符串存储在传递给 main() 的 String 数组中。

示例：

```java
public class CommandLine {

   // main 方法接收的参数就是命令行参数
   public static void main(String args[]) { 
      for(int i = 0; i<args.length; i++) {
         System.out.println("args[" + i + "]: " +  args[i]);
      }
   }
}
```

我们编译并运行这个程序，运行时传入命令行参数：

```cmd
# 编译 CommandLine.java 文件
javac CommandLine.java
# 运行 CommandLine 类，并传入命令行参数，这些参数是跟在后面的，此次的参数为：this is a command line 200 -100
java CommandLine this is a command line 200 -100
```

输出：

```console
args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
```

#### 关于 finalize() 方法

我们可以定义一个方法，在**垃圾回收器（garbage collector）**最终销毁对象之前调用。该方法称为 finalize()，可用于确保对象干净利落地终止。

例如，你可以使用 finalize() 来确保该对象打开的文件是现在已经是关闭的。

要在类中添加 finalizer，只需定义 finalize() 方法即可。每当 Java 运行时要回收该类的对象时，就会调用该方法。在 finalize() 方法中，我们可以指定**对象销毁前（before an object is destroyed）**必须执行的操作。一般写法如下：

```java
protected void finalize( ) {
   // 该方法一般是写一些对象销毁前必须执行的操作
}
```

这里，关键字 protected 是一个修饰符，它防止在其类外部定义的代码访问 finalize()。

这意味着我们无法知道何时是否会执行 finalize()。例如，如果我们的程序在垃圾回收发生之前结束，则 finalize() 将不会执行。

### 七、访问修饰符

Java 提供了 **4** 个访问修饰符来设置类、变量、方法和构造函数的访问级别。分别是：

- **default**：默认情况下，没有写任何修饰符，就是对当前包可见（可访问）
- **private**：只有当前类可见
- **public**：谁都可见，谁都可以访问，没有限制，公开的
- **protected**：对当前包和子类可见

没有任何访问控制修饰符声明的变量或方法可供同一包中的任意其他类使用。

#### 默认访问修饰符 - 没有关键字

默认访问修饰符意味着我们没有显式声明类、字段、方法等的访问修饰符。

没有任何访问控制修饰符声明的变量或方法可供同一包中的任意其他类使用。

**接口**中的字段是隐式 **public static final** 的，接口中的方法默认是 **public** 的。

示例：

```java
String version = "1.5.1";

boolean processOrder() {
   return true;
}
```

#### 私有访问修饰符 - private

声明为私有的（**private**）方法、变量和构造方法只能在声明的类本身内访问。

**private** 修饰符是最严格的访问级别。而且，类和接口不能是私有的，不然谁都访问不了，没有任何意义。

一般情况下，类中应该存在公共的 getter 方法，可以让类外部访问被 **private** 修饰的变量。

**使用 private 修饰符是对象封装自身并向外界隐藏数据的主要方式。**

示例：

```java
public class Logger {
   private String format;

   // 这个方法就是公共的 getter 方法，可以让类外部的程序访问当前类中被 private 修饰的变量
   public String getFormat() {
      return this.format;
   }

   public void setFormat(String format) {
      this.format = format;
   }
}
```

这里， *Logger* 类的 format 变量是私有的，因此其他类无法**直接检索或设置（retrieve or set）**其值。

所以，为了使这个变量可供外部使用，我们定义了两个公共的方法：

1. getFormat()，它返回 format 的值；
2. setFormat(String)，它设置它的值。

#### 公共访问修饰符 - public

声明为 **public** 的类、方法、构造方法、接口等可以被任意其他类访问。

换句话说，在公共类中声明的字段、方法、代码块可以被任意其他类访问。

不过，如果我们尝试访问的公共类位于不同的包中，则仍然需要导入该公共类。如果有类的继承，那么父类的所有公共方法和变量都会被其子类继承。

示例：应用程序的 main() 方法必须是公共的。否则，Java 解释器（例如 java 命令）无法调用它来运行该类。

```java
public static void main(String[] arguments) {
   // ...
}
```

#### 受保护的访问修饰符 - protected

在父类中声明为 **protected** 的变量、方法和构造方法，这些东西只能被其子类访问，或者跟父类同一包下的其他类访问。

protected 访问修饰符不能应用于类和接口。方法、字段可以声明为 protected，但是接口中的方法和字段不能声明为 protected。

受保护的访问使子类有机会使用辅助方法或变量，同时防止不相关的类尝试使用它。

示例：以下父类 *AudioPlayer* 对方法使用了受保护的访问控制，以允许其子类重写 openSpeaker() 方法

```java
class AudioPlayer {
   protected boolean openSpeaker(Speaker sp) {
      // 方法实现细节
   }
}

class StreamingAudioPlayer extends AudioPlayer {
   boolean openSpeaker(Speaker sp) {
      // 方法实现细节
   }
}
```

在这里，如果我们将 openSpeaker() 方法定义为私有方法，那么除 *AudioPlayer* 之外的任何其他类都无法访问该方法。如果我们将其定义为公共的，那么所有外部的 Java 类都可以访问它。但我们的目的是**仅将此方法公开给其子类**，这就是我们使用 protected 修饰符的原因。

#### 访问控制和继承

继承方法的以下规则是强制执行的：

- 在父类中声明为 public 的方法也必须在所有子类中也是 public。
- 在父类中声明为 protected 的方法在子类中必须是 protected 或 public；它们不能是 private。
- 声明为 private 的方法根本不被继承，因此没有针对它们的规则。

### 八、变量作用域

1. **对于实例变量（成员变量）来说**：实例变量的一般作用域是整个类（静态方法除外）。实例变量的生命周期是直到对象保留在内存中为止。

2. **对于类变量（静态变量）来说**：类变量的一般作用域是整个类，类变量的生命周期是直到程序结束或类加载到内存中为止。

3. **对于局部变量来说**：局部变量的作用域是在声明它的代码块内，并且局部变量的生存期是直到程序执行完声明它的代码块为止。

### 九、继承

**继承（Inheritance）**可以定义为一个类获取另一个类的属性（方法和字段）的过程。通过使用继承，可以让信息按**层次结构顺序（hierarchical order）**进行管理。

继承其他类的属性的类称为子类（派生类、衍生类），继承其他类的属性的类称为超类（基类、父类）。

> 属性：properties 
>
> 方法和字段：methods and fields
>
> 子类：subclass
>
> 派生类、衍生类：derived class, child class
>
> 超类：superclass
>
> 基类、父类：base class，parent class

#### extends 关键字

**extends** 是用于继承类的属性和方法的关键字。以下是 extends 关键字的语法：

```java
class Super {
   .....
   .....
}

class Sub extends Super {
   .....
   .....
}
```

示例：下面演示了 *Calculation* 类和其子类 *MyCalculation*，我们可以发现在子类中是可以调用父类的加法和减法的方法。

```java
public class Calculation {
   int z;
	
   public void addition(int x, int y) {
      z = x + y;
      System.out.println("加法结果:"+z);
   }
	
   public void subtraction(int x, int y) {
      z = x - y;
      System.out.println("减法结果:"+z);
   }
}
```

```java
public class MyCalculation extends Calculation {
    
   public void multiplication(int x, int y) {
      // 子类可以使用父类的变量，说明子类继承了父类的变量
      z = x * y;
      System.out.println("乘法结果:"+z);
   }
	
   public static void main(String args[]) {
      int a = 20, b = 10;
      MyCalculation demo = new MyCalculation();
      // 子类对象可以调用父类的方法，说明子类继承了父类的方法
      demo.addition(a, b);
      demo.subtraction(a, b);
      // 子类调用自己的方法
      demo.multiplication(a, b);
   }
}
```

编译并运行上述代码，输出：

```console
加法结果:30
减法结果:10
乘法结果:200
```

在给定的程序中，当创建 *MyCalculation* 类的对象时，会在其中创建其父类内容的副本。

这就是为什么使用子类的对象可以访问父类的成员（变量、方法等）。

父类引用变量可以保存子类对象（这种现象也是**多态**的体现），但使用该变量只能访问父类的成员。

```java
// 父类引用变量 demo 保存着子类对象
Calculation demo = new MyCalculation();
demo.addition(a, b);
demo.subtraction(a, b);
```

如果要访问两个类的成员，建议始终创建子类的引用变量。

**注意**：子类继承其父类的所有成员（字段、方法和嵌套类）。构造方法不是成员，因此不能被子类继承，但可以从子类中调用父类的构造方法。

#### super 关键字

**super** 关键字与 **this** 关键字类似。以下是使用 super 关键字的场景。

1. 用于**区分**父类成员和子类成员（如果它们具有相同的名称）。

下面演示了父类和子类都拥有相同的变量名称 num 和相同的方法名称 display，但是有着不同的变量值和方法实现。为了区分，就可以使用 super 关键字来区分变量和方法是父类还是子类的。

```java
public class SuperClass {
   // 父类的变量 num
   int num = 20;

   // 父类的 display() 方法
   public void display() {
      System.out.println("现在执行的是父类的 display 方法");
   }
}
```

```java
public class SubClass extends SuperClass {
   // 子类的变量 num
   int num = 10;

   // 子类的 display() 方法
   public void display() {
      System.out.println("现在执行的是子类的 display 方法");
   }

   public void myMethod() {
      // 实例化子类
      Sub_class sub = new Sub_class();

      // 调用子类的 dispaly() 方法
      sub.display();

      // 调用父类的 dispaly() 方法
      super.display();

      // 打印子类变量 num 的值
      System.out.println("子类变量 num 的值:" + sub.num);

      // 打印父类变量 num 的值
      System.out.println("父类变量 num 的值:" + super.num);
   }

   public static void main(String args[]) {
      Sub_class obj = new Sub_class();
      obj.my_method();
   }
}
```

输出：

```console
现在执行的是子类的 display 方法
现在执行的是父类的 display 方法
子类变量 num 的值:10
父类变量 num 的值:20
```

上述代码通过使用 **super** 关键字访问的变量和方法，则说明 super.num 和 super.display() 是属于父类的。

2. 用于从子类中**调用父类的构造方法。**

```java
public class SuperClass {
   // 父类的 age 变量
   int age;

   // 父类的有参构造方法
   SuperClass(int age) {
      this.age = age; 		 
   }

   public void getAge() {
      System.out.println("在父类中变量 age 的值为: " + age);
   }
}
```

```java
public class SubClass extends SuperClass {
   // 子类的有参构造方法
   SubClass(int age) {
      // 调用父类的有参构造方法，由于继承，所以子类有 age 变量，依旧会完成局部变量赋值到类变量 age 中的操作
      super(age);
   }

   public static void main(String args[]) {
      Subclass s = new Subclass(24);
      // 由于继承，没有重写 getAge()，所以 getAge() 的实现就跟父类一样
      s.getAge();
   }
}
```

输出：

```console
在父类中变量 age 的值为: 24
```

#### 继承是一种 IS-A 的关系

在英语中，这个对象是那种对象的一种类型（This object is a type of that object）

比如我们看一下这几句英语句子：

- **Mammal** IS-A Animal（**哺乳动物** 是 动物）
- **Reptile** IS-A  Animal（**爬行动物** 是 动物）
- **Dog** IS-A Mammal（**狗** 是 哺乳动物）
- 所以，我们可以知道，狗也是动物

下面，让我们看看 extends 关键字是如何实现继承关系的。

```java
public class Animal {
}

public class Mammal extends Animal {
}

public class Reptile extends Animal {
}

public class Dog extends Mammal {
}
```

基于上面的例子，用面向对象的术语来描述，那么：

- *Animal* 是 *Mammal* 类的父类
- *Animal* 是 *Reptile* 类的父类
- *Mammal* 和 *Reptile* 类都是 *Animal* 的子类
- *Dog* 是 *Mammal* 的子类，也是 *Animal* 的子类

通过使用 **extends** 关键字，**子类将能够继承父类的所有属性，除了超类的私有属性之外**。

而且，我们可以通过 **instanceof** 操作符（也可以说是关键字），来确保 Mammal 实际上是一种 Animal。

```java
public class Dog extends Mammal {

   public static void main(String args[]) {
      Animal a = new Animal();
      Mammal m = new Mammal();
      Dog d = new Dog();

      System.out.println(m instanceof Animal); // 打印 true
      System.out.println(d instanceof Mammal); // 打印 true
      System.out.println(d instanceof Animal); // 打印 true
   }
}
```

**所以，如果有时候，我们需要判断某一个对象是否属于某种类型时，就可以使用 instanceof 操作符来判断。**

比如判断当前的对象是否是字符串？当前的对象是否是整型？等等。

实际上，**implements** 关键字也能有 is a 的关系，一般情况下，就是通过 implements 关键字来继承**接口**的属性。

```java
// 把 Animal 抽象为接口
public interface Animal {
}

// Mammal 类实现 Animal 接口
public class Mammal implements Animal {
}

// Dog 类实现 Mammal 接口
public class Dog extends Mammal {
}
```

### 十、聚合

当一个对象 A 包含对另一个对象 B 的引用，或者我们可以说对象 A 与对象 B 具有 HAS-A 关系时，则称为**聚合（Aggregation）**。

除了继承，聚合也是可以达到复用代码的效果。对象 B 可以具有实用方法，并且可以被多个对象使用。无论哪个类拥有对象 B，它都可以使用其方法。

#### 聚合是一种 HAS-A 关系

这些关系主要基于用途。这决定了某个类是否**拥有某个**东西。

```java
public class Vehicle{}
public class Speed{}

public class Truck extends Vehicle {
   // 将 Speed 聚合到 Truck 中，作为一个 Speed 类型的变量
   private Speed sp;
} 
```

这里就展示了 *Truck* 类**拥有着（HAS-A）** *Speed* 类，即代表着**卡车拥有着速度**。这里 Truck 只需**拥有（持有）**Speed 引用对象 sp 就可以了，而不需要像继承那样将整个 Speed 类的代码全部放到 Truck 类中，着有助于复用 Speed 类。

在面向对象的特性中，我们作为用户，是不需要关心哪个对象是真正能工作的对象的，我们只需要知道 Truck 能根据我们的要求执行某些操作就可以了，相当于 Truck 帮我们隐藏了功能的实现细节。

当然，作为开发者的话，我们自己开发 Truck，那么肯定是需要知道 Speed 对象是在哪里创建、怎样操作才能实现某些功能的。

**示例：将 Speed 聚合到 Truck 中，即定义一个 Speed 作为 Truck 的实例变量。**

```java
package cn.god23bin.summary;

class Vehicle {
   private String brand;

   public String getBrand() {
      return brand;
   }

   public void setBrand(String brand) {
      this.brand = brand;
   }	
}

class Speed {
   private double max;

   public double getMax() {
      return max;
   }

   public void setMax(double max) {
      this.max = max;
   }
}

class Truck extends Vehicle {
   // Truck 拥有 Speed
   private Speed speed;

   public Speed getSpeed() {
      return speed;
   }

   public void setSpeed(Speed speed) {
      this.speed = speed;
   }

   public void print() {
      System.out.println("品牌: " +this.getBrand() + ", 最大速度: " + speed.getMax() );
   }
} 

public class Tester {

   public static void main(String[] args) {
      Speed speed = new Speed();
      speed.setMax(120);
      Truck truck = new Truck();

      truck.setBrand("奔驰");
      truck.setSpeed(speed);
      truck.print();
   }
}
```

输出：

```console
品牌: 奔驰, 最大速度: 120.0
```

**示例：学生拥有地址，将 Address 聚合到 Student 中，即定义一个 Address 变量作为 Student 的实例变量。**

```java
package cn.god23bin.summary;

class Address {
   String province;
   String city;
   String area;
   int streetNum;

   Address(String province, String city, String area, int streetNum) {
      this.province = province;
      this.city = city;
      this.area = area;
      this.streetNum = streetNum;
   }
}

class Student {
   int sno;
   String stName;

   // Student 拥有 Address
   Address stAddr;
   Student(int sno, String name, Address address){
      this.sno = sno;
      this.stName = name;
      this.stAddr = address;
   }
}

public class Tester {

   public static void main(String[] args) {
      Address ad = new Address(101, "广东省", "广州市", "天河区");
      Student st = new Student(1, "god23bin", ad);
      System.out.println("学号: "+ st.sno);
      System.out.println("姓名: "+ st.stName);
      System.out.println("省: "+ st.stAddr.strNum);
      System.out.println("市: "+ st.stAddr.city);
      System.out.println("区: "+ st.stAddr.state);
      System.out.println("街道编号: "+ st.stAddr.country);
   }
}
```

输出：

```console
学号: 1
姓名: god23bin
省: 广东省
市: 广州市
区: 天河区
街道编号: 101
```

#### 聚合是一种关联关系

从独特的意义上来说，这是一种**关联（association）**。**聚合（aggregation ）**是一种单向定向的关系，它精确地表达了类之间的 HAS-A 关系。此外，当两个类聚合时，终止其中一个类不会对另一个类产生影响。

与**组合（composition）**相比，聚合经常被指定为**弱关系（weak relationship）**，父实体和子实体可以各自独立存在。相比之下，在组合中，父实体拥有子实体，这意味着子实体不能直接访问，也不能离开父对象而存在。

### 十一、多态

**多态（Polymorphism ）**是指一个对象具有多种形态的能力。任何可以通过一个以上 IS-A 测试的 Java 对象都被视为是多态的。

在 Java 中，所有 Java 对象都是多态的，因为任何对象都能通过其自身类型和 Object 类的 IS-A 测试。

- A Dog IS-A Dog（狗是狗）

- A Dog IS-A Object（狗是 Object）

在 OOP 中多态的表现方式，最常见的就是发生在使用**父类引用（parent class reference）**来 **引用（refer）** **子类对象（child class object）**时。

比如：

```java
Animal animal = new Dog();
```

- Animal 是父类引用类型
- animal 是一个**引用变量（reference variable）**，访问对象的唯一方法是通过引用变量。引用变量只能是一种类型。一旦声明，引用变量的类型就不能更改。目前这个引用变量的类型就是 Animal 类型。

#### 引用变量

引用变量可以重新分配给其他对象，前提是它没有声明为final。引用变量的类型将决定它可以在对象上调用的方法。

引用变量可以引用其声明类型的任何对象或其声明类型的任何子类型。引用变量可以声明为类或接口类型。

示例：

```java
public interface Vegetarian{}
public class Animal{}
public class Deer extends Animal implements Vegetarian{}
```

现在，Deer 类被认为是多态的，因为它具有继承关系。

- A Deer IS-A Animal
- A Deer IS-A Vegetarian
- A Deer IS-A Deer
- A Deer IS-A Object

所以，我们将引用变量来引用 Deer 对象，下面的写法是完全 OK 的：

```java
Deer deer = new Deer();
// 引用变量 v 引用 deer 对象
Vegetarian v = deer;
// 引用变量 a 引用 deer 对象
Animal a = deer;
// 引用变量 o 引用 deer 对象
Object o = deer;
```

这里所有引用变量 deer、v、a、o 都引用**堆（Heap）**中的同一个 Deer 对象。

可以将这个**引用（refer）**理解成一个指针。也就是说：

deer、v、a、o 都**引用**堆中的同一个 Deer 对象 === deer、v、a、o 都**指向**堆中的同一个 Deer 对象。

### 十二、方法重写

**重写（Override）**是继承关系中可以出现的情况，如果一个类从其父类继承了一个方法，那么只要该方法未标记为 final，那么就有机会重写该方法。

重写的好处是：能够定义特定于子类类型的行为，这意味着子类可以根据其要求实现不同于父类的方法实现。

示例：

```java
class Animal {
   public void move() {
      System.out.println("动物移动中...");
   }
}

class Dog extends Animal {
   // 重写父类的 move 方法，完成不同于父类的实现
   // 父类是打印 动物移动中...，那我就不这样打印，我打印 狗狗能够奔跑
   public void move() {
      System.out.println("狗狗能够奔跑");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal 引用变量
      Animal b = new Dog();   // Animal 引用变量 引用 Dog 对象

      a.move();   // 运行 Animal 类中的 move 方法
      b.move();   // 运行 Dog 类中的 move 方法
   }
}
```

输出：

```console
动物移动中...
狗狗能够奔跑
```

在上面的示例中，我们可以看到，即使 **b** 是 Animal 的一种类型，它也运行 *Dog* 类中的 move 方法。原因是：在编译时，对引用类型进行检查。接着，在运行时，JVM 会计算出对象类型并运行属于该特定对象的方法。

所以，在上面的例子中，由于 Animal 类有 move 方法，程序将正确编译。然后，在运行时，它运行特定于该对象的方法。

**思考：那如果 Dog 类中多一个 bark 方法，b 还能调用 bark 方法吗？**

显然是不能的，因为 b 的引用类型 Animal 类中没有 bark 方法，执行 b.bark(); 就会编译错误。

**方法重写规则：**

- 参数列表应该与重写方法的参数列表完全相同。
- 返回类型应该与父类中原始重写方法中声明的返回类型相同或其子类型。
- 访问级别不能比被重写方法的访问级别更严格。例如：如果父类方法声明为 public，则子类中的重写方法不能为 private 或 protected。
- 实例方法只有被子类继承时才可以被重写。
- 声明为 final 的方法不能被重写。
- 构造方法不能被重写。
- 声明为静态的方法不能被重写，但可以重新声明。
- 如果一个方法不能被继承，那么它就不能被重写。
- 与实例的父类位于同一包中的子类可以重写任何未声明为 private 或 final 的父类方法。
- 不同包中的子类只能重写声明为 public 或 protected 的非 final 方法。
- 重写方法可以抛出任何未检查异常，无论被重写方法是否抛出异常。但是，重写方法不应抛出新的或比被重写方法声明的异常更广泛的已检查异常。重写方法可以抛出比被重写方法更窄或更少的异常。

### 十三、实例初始化块

实例初始化块（Instance Initializer Block）类似于构造方法，每个对象在创建后，就会调用一次这个初始化块。

我们可以用这个初始化块为对象设置一些初始值。

示例：

```java
public class Tester {
   public int a;
   // 由 {} 组成的就是实例初始化块
   { a = 10; }   
}
```

- 一旦创建了对象，就会调用实例初始化块。
- 调用完实例初始化块后，后面才调用对象的构造方法
- 对于子类，实例初始化块将在父类的构造方法调用之后被调用。
- 实例初始化块可用于执行多个语句。
- 实例初始化块通常用于实例化多个字段值（属性值），例如数组。

**示例1：实例初始化块在构造方法之前执行**

```java
public class Tester {
   {
      System.out.println("执行实例初始化块中...");
   }
   
   Tester(){
      System.out.println("执行构造方法中...");
   }
   
   public static void main(String[] arguments) {
      Tester test = new Tester();
   }
}
```

输出：

```console
执行实例初始化块中...
执行构造方法中...
```

**示例2：实例初始化块中初始化的值会被构造方法覆盖**

```java
public class Tester {
   int a;
   {
      System.out.println("执行实例初始化块中...");
      a = 10;
   }
   
   Tester(){
      System.out.println("执行构造方法中...");
      a = 20;
   }
   
   public static void main(String[] arguments) {
      Tester test = new Tester();
      System.out.println("a = " + a);
   }
}
```

输出：

```console
执行实例初始化块中...
执行构造方法中...
a = 20
```

**示例3：执行子类的实例初始化块之前会调用父类构造方法**

```java
class SuperTester{
   SuperTester(){
      System.out.println("执行父类的构造方法中...");
   }
}

public class Tester extends SuperTester {
   int a;
   {
      System.out.println("执行实例初始化块中...");
      a = 10;
   }

   Tester(){
      System.out.println("执行构造方法中...");
   }

   public static void main(String[] arguments) {
      Tester test = new Tester();
      System.out.println("a = " + test.a);
   }
}
```

输出：

```console
执行父类的构造方法中...
执行实例初始化块中...
执行构造方法中...
a = 10
```

### 十四、抽象

> 当我们觉得一个词的解释难于理解时，通常说这个词或其解释太“抽象”。日常语言中，“抽象”这个词几乎成了难于理解的代名词。然而，这不该是“抽象”原本的意思，或者说不该是它的主要意思。

你们看下面这个动图，看是否很抽象？有没有熟悉的感觉？你干嘛哎呦？

![img](https://picx.zhimg.com/50/v2-7cf03b0dabf2b628db7836017bce2e46_720w.gif?source=1def8aca)

抽象，反义词就是所谓的具体，上图具体是什么我就不说了，反正是很抽象的。

**在面向对象编程中，抽象是指向用户隐藏实现细节的过程，或者说只是做规划，做决策，仅提供程序应该有什么功能，而不负责具体的功能实现。**

就好比上级领导，给我们安排任务，下达的命令，说，小王啊，帮我写一份 PPT，这件事本身就是抽象的，并没有说该怎么写，具体怎么写就不知道了，反正就只是安排任务。

在英文中，抽象的描述是：**abstraction** is the quality of dealing with ideas rather than events.

也就是说，**抽象是只处理想法，而不处理真正的事情。**

在 Java 中，抽象是通过**抽象类**和**接口**来实现的，也就是说抽象类和接口扮演了上级领导的角色，负责说一些规划，并不负责具体的功能实现。那么具体的功能实现是交给谁来实现呢？那当然是底层的员工啦，就是各种**接口实现类**以及**抽象类的实现类**。

#### 抽象类

在声明中包含 **abstract** 关键字的 Java 类称为抽象类。

- Java 抽象类可能包含也可能不包含**抽象方法**，即没有主体的方法（ public void get(); ）
- 但是，如果一个类至少有一个抽象方法，那么该类**必须**声明为抽象的。
- 如果一个类被声明为抽象类，则它不能被实例化。
- 要使用抽象类，必须用另一个类继承它，并提供其中抽象方法的实现。
- 如果继承抽象类，则必须提供其中所有抽象方法的实现。

示例：

声明类的时候使用 abstract 关键字，表示该类为抽象类

```java
public abstract class Employee {
   private String name;
   private String address;
   private int number;

   public Employee(String name, String address, int number) {
      System.out.println("正在构造 Employee 对象");
      this.name = name;
      this.address = address;
      this.number = number;
   }
   
   public double computePay() {
     System.out.println("在 Employee computePay 方法中");
     return 0.0;
   }
   
   public void mailCheck() {
      System.out.println("邮件检查: " + this.name + " " + this.address);
   }

   public String toString() {
      return name + " " + address + " " + number;
   }

   public String getName() {
      return name;
   }
 
   public String getAddress() {
      return address;
   }
   
   public void setAddress(String newAddress) {
      address = newAddress;
   }
 
   public int getNumber() {
      return number;
   }
}
```

虽然看起来和普通的类相同，但该类现在是抽象的，不过它仍然具有 3 个属性、7 个方法和 1 个构造方法。

我们尝试实例化这个类，则编译会发生错误：

```java
public class AbstractDemo {
   public static void main(String [] args) {
      // 实际上，下面的实例化是不允许的，是不可行的，会产生错误
      Employee e = new Employee("god23bin", "广州市天河区", 43);
      e.mailCheck();
   }
}
```

输出错误：

```console
Employee.java:46: Employee is abstract; cannot be instantiated
      Employee e = new Employee("god23bin", "广州市天河区", 43);
                   ^
1 error
```

那么，想要使用抽象类，就需要另一个类来继承这个抽象类，并实现抽象类的所有抽象方法。

```java
public class Salary extends Employee {
   private double salary;   // 年薪
   
   public Salary(String name, String address, int number, double salary) {
      super(name, address, number);
      setSalary(salary);
   }
   
   public void mailCheck() {
      System.out.println("在 Salary 类的 mailCheck 方法中");
      System.out.println("邮件检查: " + getName() + " 的薪水为 " + salary);
   }
 
   public double getSalary() {
      return salary;
   }
   
   public void setSalary(double newSalary) {
      if(newSalary >= 0.0) {
         salary = newSalary;
      }
   }
   
   public double computePay() {
      System.out.println("计算薪水中，将支付给: " + getName());
      return salary/52;
   }
}
```

我们可以实例化 *Salary* 类，并且使用该实例我们就可以访问 *Employee* 类的所有属性和方法。

```java
public class AbstractDemo {2
   public static void main(String [] args) {
      Salary s = new Salary("god23bin", "广州市天河区", 3, 3600.00);
      Employee e = new Salary("亚瑟", "马掌望台", 2, 2400.00);
      System.out.println("使用 Salary 引用类型去调用 mailCheck 方法 --");
      s.mailCheck();
      System.out.println("\n 使用 Employee 引用类型去调用 mailCheck 方法--");
      e.mailCheck();
   }
}
```

输出：

```console
正在构造 Employee 对象
正在构造 Employee 对象
使用 Salary 引用类型去调用 mailCheck 方法 --
在 Salary 类的 mailCheck 方法中
邮件检查: god23bin 的薪水为 3600.0

 使用 Employee 引用类型去调用 mailCheck 方法--
在 Salary 类的 mailCheck 方法中
邮件检查: 亚瑟 的薪水为 2400.0
```

#### 抽象方法

如果我们希望一个类包含特定方法，但希望该方法的实际实现由子类确定，则可以在父类中将该方法声明为抽象方法。

- **abstract** 关键字用于将方法声明为抽象方法。
- 您必须将**抽象**关键字放在方法声明中的方法名称之前。
- 抽象方法包含方法签名，但不包含方法体。
- 抽象方法末尾将有一个符号冒号 (;)，而不是花括号。

示例：

抽象类 *Employee*

```java
public abstract class Employee {
   private String name;
   private String address;
   private int number;
   
   // 抽象的方法，没有具体的实现，交给其子类确定
   public abstract double computePay();
    
   // 其他代码...
}
```

- 包含抽象方法的类必须声明为抽象类。
- 继承抽象类的任何其他类都必须重写抽象方法或将自身声明为抽象类。

*Employee* 的实现类 *Salary* 类

```java
public class Salary extends Employee {
   private double salary;   // 年薪

   public Salary(String name, String address, int number, double salary) {
      super(name, address, number);
      this.salary = salary;
   }

   // 这里就实现了抽象类 Employee 的抽象方法 computePay
   public double computePay() {
      System.out.println("计算薪水中，将支付给: " + getName());
      return salary/52;
   }
    
   // 其他代码...
}
```

### 十五、封装

**封装（encapsulation）**是 4 个基本的 OOP 概念之一。另外 3 个是继承、多态和抽象。

Java 中的封装是一种机制，这种机制可以将数据（变量）和作用于数据的代码（方法）包装在一起作为一个单元。

在封装中，一个类的变量将对其他类隐藏，并且只能通过当前类的方法来访问。因此，也称为**数据隐藏**。

#### 封装的体现

Java 中封装的体现是在：

- **将类的变量声明为私有的（private）。**
- **提供公共的 setter 和 getter 方法来修改和查看变量值。**

示例：

```java
public class EncapTest {
   // 私有变量
   private String name;
   private String idNum;
   private int age;

   // 提供公共的 setter 和 getter
   public int getAge() {
      return age;
   }

   public String getName() {
      return name;
   }

   public String getIdNum() {
      return idNum;
   }

   public void setAge( int newAge) {
      age = newAge;
   }

   public void setName(String newName) {
      name = newName;
   }

   public void setIdNum( String newId) {
      idNum = newId;
   }
}
```

公共的 setXXX() 和 getXXX() 方法是 *EncapTest* 类的实例变量的访问点。通常，这些方法称为 **getter** 和 **setter**。因此，任何想要访问变量的类都应该通过这些 getter 和 setter 来访问它们。

```java
public class RunEncap {
   public static void main(String args[]) {
      EncapTest encap = new EncapTest();
      // 通过 getter 和 setter 来访问变量
      encap.setName("god23bin");
      encap.setAge(20);
      encap.setIdNum("123456");

      System.out.print("姓名 : " + encap.getName() + " 年龄 : " + encap.getAge());
   }
}
```

输出：

```console
姓名 : god23bin 年龄 : 20
```

#### 封装的好处

- 类的字段（属性）可以设置为只读或只写。
- 类可以完全控制其字段中存储的内容。

### 十六、接口

**类**描述了对象的属性和行为，**接口（Interface）**则包含类实现的**行为**。

**接口**在 Java 中是引用类型，它与**类**相似。

相似之处在于：

- 一个接口可以包含任意数量的方法。
- 接口被写入扩展名为 **.java** 的文件中，接口的名称与文件的名称相匹配。
- 接口的字节代码出现在 **.class** 文件中。
- 接口出现在包中，其对应的字节码文件必须位于与包名称匹配的目录结构中。

当然，接口在下面的几个方面与类是不同的：

- 无法实例化接口。
- 接口不包含任何构造方法。
- 接口中的所有方法都是抽象的。
- 接口不能包含实例字段。唯一可以出现在接口中的字段必须声明为 static 和 final。
- 接口不能由类**扩展（extends）**；它是由一个类来**实现（implements）**的。
- 一个接口可以**扩展（extends）**多个接口。

简单来说，接口是抽象方法的集合。类实现了接口，从而继承了接口的抽象方法。

除了抽象方法之外，接口还可以包含常量、默认方法、静态方法和嵌套类型。方法体仅存在于默认方法和静态方法中。

除非实现接口的类是抽象的，否则接口的所有方法都需要在类中定义。

#### 声明接口

示例：直接使用 **interface** 关键字声明接口

```java
public interface NameOfInterface {
   // 任意数量的 final, static 字段（属性）
   // 任意数量的 抽象方法声明
}
```

- 接口是隐式抽象的。声明接口时不需要使用 **abstract** 关键字。
- 接口中的每个方法也是隐式抽象的，因此不需要 abstract 关键字。
- 接口中的方法是隐式公共的。

```java
interface Animal {
   void eat(); // 等价于 public abstract void eat();
   public void travel();
}
```

#### 实现接口

类使用 **implements** 关键字来实现接口。

示例：*Mammal* 类实现 *Animal* 接口

```java
public class Mammal implements Animal {

   // 实现接口的方法
   public void eat() {
      System.out.println("Mammal eats");
   }

   public void travel() {
      System.out.println("Mammal travels");
   } 

   public static void main(String args[]) {
      Mammal m = new Mammal();
      m.eat();
      m.travel();
   }
}
```

当一个类实现了一个接口时，你可以认为该类签署了一份协议，同意执行该接口的特定行为。

如果一个类不执行接口的所有行为，则该类必须将自己声明为抽象类。

注：**implements** 关键字出现在类声明中声明的 extends 部分之后。

#### 相关规则

当重写接口中定义的方法时，需要遵循几条规则：

- 除了接口方法声明的实现方法或接口方法声明的实现方法的子类外，不应在其他实现方法上声明受检查的异常。
- 重写方法时应保持接口方法的签名以及相同的返回类型或子类型。
- 实现类本身可以是抽象的，如果是这样，则不需要实现接口方法。

实现接口时，有几个规则：

- 一个类可以同时实现多个接口。
- 一个类只能继承（扩展）一个类，但实现多个接口。即所谓的**单继承、多实现**。

#### 扩展接口

接口可以继承（扩展）另一个接口，就像类可以继承（扩展）另一个类一样。

示例：扩展接口

```java
// 文件名: Sports.java
public interface Sports {
   public void setHomeTeam(String name);
   public void setVisitingTeam(String name);
}

// 文件名: Football.java
public interface Football extends Sports {
   public void homeTeamScored(int points);
   public void visitingTeamScored(int points);
   public void endOfQuarter(int quarter);
}

// 文件名: Hockey.java
public interface Hockey extends Sports {
   public void homeGoalScored();
   public void visitingGoalScored();
   public void endOfPeriod(int period);
   public void overtimePeriod(int ot);
}
```

*Hockey* 接口有 4 个方法，但它从 *Sports* 继承了两个方法；因此，实现 *Hockey* 的类需要实现所有 6 个方法。

同样，实现 *Football* 的类需要实现 *Football* 中的 3 个方法和 *Sports* 中的两个方法。

示例：*Hockey* 的实现类 *HockeyDemo*

```java
public class HockeyDemo implements Hockey {

   public void setHomeTeam(String name) {
      System.out.println("主队: " + name);
   }

   public void setVisitingTeam(String name) {}

   public void homeGoalScored() {}

   public void visitingGoalScored() {}

   public void endOfPeriod(int period) {}

   public void overtimePeriod(int ot) {}

   public static void main(String[] args) {
      Hockey hockeyDemo = new HockeyDemo();
      hockeyDemo.setHomeTeam("中国");
   }
}
```

输出：

```console
主队: 中国
```

#### 扩展多个接口

一个 Java 类只能继承一个父类。不允许多重继承。但是，接口不是类，一个接口可以扩展（继承）多个父接口。

**extends** 关键字使用一次，并且父接口在逗号分隔的列表中声明。

例如，如果 Hockey 接口扩展了 Sports 和 Event，则它将声明为：

```java
public interface Hockey extends Sports, Event
```

#### 标记接口

没有方法的接口称为**标记**接口（**tagging** interface）。

在 java.awt.event 包中的 MouseListener 接口就扩展了 java.util.EventListener 接口，而 EventListener 接口就是一个没有方法的接口，作为标记接口。

标记接口有两个基本设计目的：

1. **创建公共父级**：与由 Java API 中的数十个其他接口扩展的 EventListener 接口一样，我们可以使用标记接口在一组接口中创建公共父级。例如，当接口扩展 EventListener 时，JVM 知道该特定接口将在事件委托场景中使用。

2. **向类添加数据类型**：这种情况就是术语“标记”的由来。实现标记接口的类不需要定义任何方法（因为该接口没有任何方法），但该类通过多态性成为接口类型。

### 十七、内部类

一个类中可以有方法、变量，那现在我告诉你，一个类中还可以有类，就如同方法、变量一样作为类的成员。

在一个类中在编写一个类，在 Java 中是允许的，这种类称为**嵌套类（nested class）**，而拥有着这个嵌套类的类，则称为**外部类（outer class）**

语法如下：

```java
class OuterDemo {
   class InnerDemo {
   }
}
```

嵌套类分为两种：

1. **非静态嵌套类（内部类）**：这些嵌套类作为外部类的非静态成员。

2. **静态嵌套类**：这些嵌套类作为外部类的静态成员。

#### 非静态嵌套类（内部类）

我们知道，一个类是不能访问被 private 修饰的变量、方法的，那如果我就是想要让一个类能够访问被 private 修饰的变量和方法，该怎么办？

此时，就可以将一个类作为类的成员，成为一个嵌套类，那么自然这个嵌套类就能够访问其他被 private 修饰的变量和方法了，因为 private 修饰的变量和方法只能在当前类中可访问。

非静态嵌套类也习惯称为**内部类（inner class）**

内部类分为三种：

1. 内部类
2. 方法局部内部类
3. 匿名内部类

#### 内部类

创建内部类非常简单。我们只需要在类中编写一个类即可。与类不同，内部类可以是私有的，一旦将内部类声明为私有，就无法从类外部的对象访问它。

**示例1：以下是创建内部类并访问它的程序。在给定的示例中，我们将内部类设为私有并通过方法访问该类。**

```java
class OuterDemo {
   int num;
   
   // 私有的内部类，也是和变量、方法同级别，都作为类的成员
   private class InnerDemo {
      public void print() {
         System.out.println("这是一个内部类");
      }
   }
   
   // 通过方法来访问内部类
   void displayInner() {
      InnerDemo inner = new InnerDemo();
      inner.print();
   }
}
   
public class MyClass {

   public static void main(String args[]) {
      // 实例化外部类 
      OuterDemo outer = new OuterDemo();
      
      // 调用 displayInner 方法
      outer.displayInner();
   }
}
```

输出：

```console
这是一个内部类
```

**示例2：访问私有成员（比如变量）**

```java
class OuterDemo {
   // 外部类私有变量
   private int num = 175;  
   
   // 内部类，也是和变量、方法同级别，都作为类的成员
   public class InnerDemo {
      // 内部类的方法，可以访问外部类的私有变量
      public int getNum() {
         System.out.println("这里是内部类的 getNum 方法");
         return num;
      }
   }
}

public class MyClass2 {

   public static void main(String args[]) {
      // 实例化外部类
      OuterDemo outer = new OuterDemo();
      
      // 实例化内部类
      OuterDemo.InnerDemo inner = outer.new InnerDemo();
      System.out.println(inner.getNum());
   }
}
```

输出：

```console
这里是内部类的 getNum 方法
175
```

#### 方法局部内部类

我们可以在方法中编写一个类，这个类将是一个局部类型的类，就像局部变量一样，这个类的作用域也是限制在这个方法中。

这种类称为**方法局部内部类（method-local inner class）**。

示例：

```java
public class OuterClass {
   // 外部类的方法
   void myMethod() {
      int num = 23;

      // 方法局部内部类
      class MethodInnerDemo {
         public void print() {
            System.out.println("这是一个方法局部内部类 " + num);	   
         }   
      } // 到这内部类的定义结束了
	   
      // 访问内部类
      MethodInnerDemo inner = new MethodInnerDemo();
      inner.print();
   }
   
   public static void main(String args[]) {
      Outerclass outer = new Outerclass();
      outer.myMethod();	   	   
   }
}
```

输出：

```console
这是一个方法局部内部类 23
```

#### 匿名内部类

没有类名声明的内部类称为**匿名内部类（anonymous inner class）**。

对于匿名内部类，我们同时声明和实例化它们。一般情况下，每当我们需要重写类或接口的方法时，就会使用到它们。

匿名内部类的语法如下：

```java
AnonymousInner an_inner = new AnonymousInner() {
   public void my_method() {
      ........
      ........
   }   
};
```

示例：

```java
abstract class AnonymousInner {
   public abstract void mymethod();
}

public class Outer_class {

   public static void main(String args[]) {
      // 声明并实例化这个匿名内部类，正常情况下，我们是需要写一个类来实现 AnonymousInner 接口的，现在使用匿名内部类就更方便
      AnonymousInner inner = new AnonymousInner() {
         public void mymethod() {
            System.out.println("这是匿名内部类的示例");
         }
      };
      inner.mymethod();	
   }
}
```

#### 匿名内部类作为参数

如果一个方法接收的对象是接口对象、抽象类或具体类的对象，那么我们可以把实现了接口的对象、实现类抽象类的对象或具体类的对象直接作为参数传递给这个方法。

不过，当出现这种情况的时候，我们其实是可以**直接使用匿名内部类传递给这个方法**的，这样我们就不用自己写多一个实现了接口的类或者实现了抽象类的类了。

语法：

```java
obj.myMethod(new MyClass() {
   public void Do() {
      .....
      .....
   }
});
```

示例：

```java
interface Message {
   String greet();
}

public class MyClass {
   // 这里有一个把接口作为参数的方法
   public void displayMessage(Message m) {
      System.out.println(m.greet() +
         ", 这里是一个示例，关于把匿名内部类作为参数传递给方法的示例");  
   }

   public static void main(String args[]) {
      // 实例化
      MyClass obj = new MyClass();

      // 直接传递匿名内部类
      obj.displayMessage(new Message() {
         public String greet() {
            return "Hello";
         }
      });
   }
}
```

输出：

```console
Hello, 这里是一个示例，关于把匿名内部类作为参数传递给方法的示例
```

#### 静态嵌套类

静态嵌套类就是一个使用 static 修饰的嵌套类，是外部类的静态成员。

可以使用其他静态成员来访问它，而无需实例化外部类。就像静态成员一样，静态嵌套类无法访问外部类的实例变量和方法。

静态嵌套类的语法如下：

```java
class MyOuter {
   static class NestedDemo {
   }
}
```

示例：

```java
public class Outer {
   static class NestedDemo {
      public void myMethod() {
         System.out.println("这是静态嵌套类");
      }
   }
   
   public static void main(String args[]) {
      Outer.NestedDemo nested = new Outer.NestedDemo();	 
      nested.myMethod();
   }
}
```

### 十八、数字类（包装类）

通常，当我们使用数字时，我们使用的是基本数据类型，例如 byte、int、long、double 等。但是，在开发过程中，我们会遇到需要使用对象而不是基本数据类型的情况。为了实现这一点，Java 提供了**包装类（wrapper classes）**。

所有包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。Number 类是 java.lang 包的一部分。

包装类的对象**包含或包装（contains or wraps）**其各自的基本数据类型。

将基本数据类型转换为对象的过程称为**装箱（boxing）**，这是由编译器负责的。因此，在使用包装类时，我们只需将基本数据类型的值传递给包装类的构造方法就可以了。

自然而然，将包装对象转换回基本数据类型，这个过程则称为**拆箱（unboxing）**。

示例：

```java
public class Test {
   public static void main(String args[]) {
      Integer x = 5; // 将 int 类型的值分配给 x 对象，这就是装箱
      x =  x + 10;   // x 对象加 10，需要把 x 拆箱为 int 类型并执行加法，最后将结果分配给 x 装箱
      System.out.println(x); 
   }
}
```

### 十九、枚举类

枚举，就是把每一种情况都一一列举出来，这个过程就是枚举。

示例：手机枚举类，有华为、小米和荣耀

```java
public enum Mobile {
   Huawei,
   Xiaomi,
   Honor
}
```

枚举主要是作为一些常量，便于操作，而不是使用字面量和魔法值。

```java
public class EnumDemo {
   public static void main(String args[]) {
      
      // 打印枚举
      System.out.println(Mobile.Huawei);

      Mobile mobile = Mobile.Huawei;
      // 在 if 中的使用
      if(mobile == Mobile.Huawei) {
         System.out.println("Huawei");
      }
      // 在 switch 中的使用
      switch(mobile) {
         case Huawei:
            System.out.println("华为");
            break;
         case Xiaomi:
            System.out.println("小米");
            break;
         case Honor:
            System.out.println("荣耀");
      }
   }
}
```

